---
title: EEA以太坊企业联盟安全规范第三版
comment: true
date: 2025-08-03 13:01:59
tags: Block, ETH, Security
---

# EEA EthTrust 安全等级规范 第3版
2025年3月

### ​​当前版本​​:
https://entethalliance.org/specs/ethtrust-sl/v3/

### ​​本版本检查清单​​:
https://entethalliance.org/specs/ethtrust-sl/v3/checklist.html

### ​​最新编辑草案​​:
https://entethalliance.github.io/eta-registry/security-levels-spec.html

### ​​编辑​​:
[EEA 编辑](editor@entethalliance.org)

### ​​最新发布版本URL​​:
https://entethalliance.org/specs/ethtrust-sl/

### ​​本版本贡献者​​:
除所有为之前版本做出贡献的人员外，以下人员对本版本规范有具体贡献：
Chaals Neville、Anish Agrawal (Olympix)、Kenan Bešić (ChainSecurity)、Daniel Burnett、Valerian Callens、Luke Ciattaglia (Hacken)、Christopher Cordi、
Ignacio Freire (Olympix)、Aminadav Glickshtein (EY)、Opal Graham (CertiK)、Channi Greenwall (Olympix)、James Harsh、Sebastian Holler、
George Kobakhidze (Diligence)、Michael Lewellen (OpenZeppelin)、Luis Lubeck (Hacken)、Dominik Muhs、Anton Permenev (ChainSecurity)、
Juliano Rizzo (Coinspect)、Gernot Salzer、Clara Schneidewinde、Tobias Vogel (Diligence)、Morgan Weaver (OpenZeppelin)

### 版权声明
© 2020-2025 企业以太坊联盟 (Enterprise Ethereum Alliance)。

### 摘要
本文档定义了EEA EthTrust认证的要求，该认证是一组证明智能合约已通过审查且未包含特定安全漏洞的认证。

### 文档状态
本节描述了本文档发布时的状态。新文档可能会取代本文档。
本文档是​​EEA EthTrust安全等级规范第3版​​，由EthTrust安全等级工作组开发，企业以太坊联盟公司发布。
本草案内容已获EEA批准发布。工作组预计在发布时将继续工作，并在2026年下半年最终确定并发布新版本以取代本文档。
本规范由企业以太坊联盟公司根据Apache许可证2.0版授权。除非EEA明确书面授权，否则您只能根据该许可证的条款使用本规范。
除非适用法律要求或书面同意，本规范按“原样”分发，不提供任何明示或暗示的担保或条件。
对本规范的反馈可直接发送至编辑EEA Editor，或作为问题提交至EthTrust-public GitHub仓库。

​​GitHub Issues​​是讨论本规范的首选方式。

## 1. 简介
__本节为非规范性内容。__
本文档定义了为用Solidity编写的智能合约授予EEA EthTrust认证的要求。
EEA EthTrust认证是安全审查员的一项声明，表明根据审查员针对特定要求的评估，​​被测代码​​不易受到一系列已知攻击或预期操作失败的影响。

没有任何安全审查可以保证智能合约免受所有可能的漏洞攻击，如第三章. 安全考虑中进一步解释。然而，根据本规范中的要求审查智能合约，可以提供保证，确保其不易受到一组已知的潜在攻击。

这种保证不仅基于审查员的声誉，还基于来自许多竞争组织的众多安全专家在EEA内的协作，确保本规范定义了对真实且重要的一组已知漏洞的防护。

### 1.1 如何阅读本规范
本节介绍如何理解本规范，包括示例和要求的约定、核心概念、参考文献、说明性章节等。

#### 1.1.1 文档概述
文档结构大致如下：
​**​前置内容​​**：文档基本信息（作者、版权等）
​**​符合性章节**​​：声明符合本规范的含义和形式
**​​安全考虑**​​：与智能合约相关的关键安全概念介绍
​**​测试方法**​​：与本规范相关的不同测试方法介绍
**​​EthTrust安全等级**​​：文档核心部分。按等级和主题分组的安全审查要求
​​**附加信息**​​：
- 术语表
- 要求和推荐实践的摘要
- 致谢
- 自上一版本以来的重大变更摘要
- 已从早期版本中移除的需求列表
​​**参考文献**​​：扩展阅读，包括必要的规范性引用和说明性引用

本规范附有​​[检查清单](https://entethalliance.org/specs/ethtrust-sl/v3/checklist.html)​​，以表格形式列出所有要求。熟悉本规范的开发者或审查员可使用该清单快速回顾每个单独要求并跟踪测试状态。如有任何差异，以本规范文档中的规范性文本为准。

#### 1.1.2 排版约定
​​要求​​的结构和格式详见§1.1.3。
部分位置提供​​示例​​。这些示例不是要求，也不具有规范性。
示例通过带边框的背景和标题进行区分，如下所示：

​​示例1：示例的示例​​
示例中可以包含行内代码如`code()`，也可以包含代码块：
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

contract HelloWorld {
    string public greeting = "Hello World";
}
```
部分示例展示​​易受攻击的代码​​或​​不应采取的做法​​。
将此类示例复制到生产代码中是非常危险的行为。这些示例会标记为警告：
```
​​警告​​
​​示例2：问题示例 - 请勿复制​​
部署未经安全审查的代码是危险行为。
```
​​术语定义​​的格式为​**​加粗**​​，后续对已定义术语的引用会以链接形式呈现，如​​术语​​。
对其他文档的引用以方括号内链接形式给出，如[CWE]。
对要求的引用以安全等级开头：[S]、[M]或[Q]，对推荐实践的引用以[GP]开头。它们会包含要求或实践名称，并以加粗链接形式呈现：
```
​​示例3​​
示例链接：[M] 记录特殊代码用途。
```
在语句或要求中引入并后续描述的​​变量​​格式为`var`。
偶尔出现的说明性注释（如下所示）不具有规范性，不构成正式要求：
```
​​注意​​：注释用于说明
注释内容旨在提供有用信息，但不构成要求。
```
#### 1.1.3 如何阅读要求
本文档的核心是​​共同定义了EEA EthTrust认证的要求。
要求包含：
- 安全等级（[S]、[M]或[Q]）
- 名称
- 链接（以"🔗🔗"标识）
- 满足要求必须实现的声明

工作组确保本编辑草案中要求的URL始终指向工作组编辑草案中的最新版本要求（可能代表未完成的进展）。
部分相同安全等级的要求会分组在小节中，因为它们与特定主题或潜在攻击领域相关。
要求后跟解释，包括：
- 该要求的重要性
- 测试方法
- 覆盖要求和相关要求的链接
- 测试用例
- 其他有用信息的链接
除要求外，本文档还包含​​§5.4 推荐良好实践​​，格式类似但安全等级标记为"[GP]"。
为符合规范，无需实施这些实践，但若谨慎实施可提高智能合约安全性。

以下要求示例：
```
​​示例4：简单要求​​
[S] 编译器漏洞SOL-2022-5与.push()
🔗🔗
被测代码若：
- 从calldata或内存复制字节数组，且其大小不是32字节的倍数
- 包含对结果数组执行空.push()指令
则​​必须不使用​​早于0.8.15的Solidity编译器版本。
```
在Solidity编译器0.8.15之前，复制长度非32字节倍数的内存或calldata可能暴露超出复制范围的数据，这些数据可通过assembly{}观察到。
另见2022年6月15日安全警报和相关要求[M] assembly{}中的编译器漏洞SOL-2022-5。

这是一个安全等级[S]要求，"[S]"前缀表示其等级。
其名称为"编译器漏洞SOL-2022-5与.push()"。
编辑草案中的URL（通过"🔗🔗"链接）为：
https://entethalliance.github.io/eta-registry/security-levels-spec.html#req-1-compiler-SOL-2022-5-push

要求声明为：
"被测代码若...必须不使用早于0.8.15的Solidity编译器版本。"
要求后是对相关漏洞的简要解释和其他讨论链接。

​**​注意**​​
良好实践的格式与要求相同，但等级标记为[GP]。如§5.4所述，满足这些实践并非必须，也不会单独改变对本规范的符合性。

##### 1.1.3.1 覆盖要求
部分要求的声明包含替代条件，由关键词`unless`引入，标识一个或多个​​覆盖要求​​。
这些是更高安全等级的要求，若被测代码不直接满足较低等级要求，可通过满足这些覆盖要求来实现符合性。

某些情况下需满足多个覆盖要求才能覆盖原要求，此时这些要求被称为​​覆盖要求集合​​。
必须满足集合中所有要求才能视为覆盖原要求。

许多情况下，一个要求可能有多个覆盖要求或覆盖要求集合可供选择以满足该要求。
例如，有时可通过以下方式满足安全等级[S]要求：
- 直接满足
- 满足安全等级[M]的覆盖要求集合
- 满足安全等级[Q]的覆盖要求集合
- 覆盖要求支持对常见简单情况进行更简单的测试。

对于使用需要额外谨慎处理功能的更复杂被测代码，它们确保此类使用经过适当检查。

典型的安全等级[S]要求中，覆盖要求适用于相对罕见的情况或自动化系统通常无法验证被测代码是否满足要求的情况。
通过进一步验证适用的覆盖要求，可确定被测代码是否正确使用功能，从而通过安全等级[S]要求。

若被测代码不满足某要求且无适用的覆盖要求，则该代码不符合EEA EthTrust认证条件。
但即使对于此类情况，请注意推荐实践[GP]尽可能满足更多要求；满足本规范中的任何要求都将提高被测代码的安全性。

在以下要求中：
- 安全等级为"[S]"
- 名称为"禁用tx.origin"
- 覆盖要求为"[Q] 验证tx.origin用法"
```
​​示例5：带覆盖要求的要求示例​​
[S] 禁用tx.origin
🔗🔗
被测代码​​不得​​包含tx.origin指令，除非满足覆盖要求[Q] 验证tx.origin用法。
```
不包含tx.origin指令的要求可通过自动化验证。
满足安全等级[Q]覆盖要求[Q] 验证tx.origin用法的被测代码视为符合此安全等级[S]要求。

作为其他要求的覆盖要求或属于覆盖要求集合的要求会明确说明：
```
​​示例6：覆盖要求示例​​
[M] 禁用非必要Unicode控制符
🔗🔗
被测代码​​不得​​使用Unicode方向控制字符，除非：
```
它们对正确渲染文本是必要的
渲染结果不会误导读者
这是[S] 禁用Unicode方向控制字符的覆盖要求。

##### 1.1.3.2 相关要求
许多要求有​​相关要求​​，即解决主题相关问题的其他要求。
提供这些链接作为有用信息。与覆盖要求不同，满足相关要求不能替代满足特定要求来实现符合性。

### 1.2 为什么需要认证合约？
__本节为非规范性内容。__
以太坊上支撑去中心化应用的许多智能合约已被发现存在安全问题，而目前在发起交易前往往难以实际评估某个地址或合约的安全性。特别是在DeFi领域，用户快速批准代币合约交易、兑换代币和为资金池添加流动性的操作中，有时会忽略安全检查。

要让企业信任以太坊作为关键数据存储或大额资本转移的交易层，需要明确的信号表明合约已通过适当的安全审计。在区块链开发背景下，生产部署前的早期审查尤为重要，因为尝试在部署后更新或修补智能合约所需的时间、精力、资金和/或信誉成本通常远高于其他软件开发场景。

本智能合约安全标准旨在提升对智能合约安全审计质量的信心，从而增强整个以太坊生态系统的信任度。认证不仅为智能合约的实际或潜在用户提供价值，也为可能受智能合约使用或滥用影响的其他利益相关方提供价值。通过EEA EthTrust认证限制暴露于某些已知弱点，这些利益相关方可以受益于风险降低和对被测代码安全性的信心提升。

需要注意的是，这种保证并不完整：例如它依赖于出具认证的审计师的能力和诚信。专业声誉可能基于被测代码的后续表现而变化，特别是当被测代码变得足够引人注目以至于激励利用认证后剩余的弱点时。

最后，当其他方（包括直接竞争对手）完成认证流程时，智能合约开发者和生态系统利益相关方也会获得价值，因为这意味着其他合约不太可能产生与利用相关的负面新闻，这些新闻可能导致商业领袖、潜在客户/用户、监管机构和投资者对以太坊技术产生不安全或高风险的负面看法。

智能合约安全认证的价值在某些方面类似于适用于飞机部件的认证流程。最直接的是，它通过提供最低质量保证，帮助部件制造商和集成商降低风险。间接而言，这些流程显著减少了航空事故和坠机，拯救生命并赢得监管机构和考虑行业整体安全与风险的客户的信任。许多安全认证流程最初是作为制造商创建的自愿程序，或代表重要市场份额的客户联盟指定和要求开始的。在证明其价值后，其中一些认证流程现在已成为法律要求以保护公众。

我们希望认证流程的价值能激励其频繁使用，并推动开发使评估过程更简单、更便宜的自动化工具。随着新的安全漏洞、本规范中的问题以及实施挑战的发现，我们希望它们能带来反馈并增加参与企业以太坊联盟EthTrust安全等级工作组或其继任者的积极性，这些工作组负责开发和维护本规范。

### 1.3 开发安全的智能合约
__本节为非规范性内容。__

本规范要求检查的安全问题对智能合约开发者（尤其是这个快速发展的领域的新手）来说并不总是显而易见的。通过让自有代码完成认证流程（即使没有潜在客户要求），智能合约开发者可以在部署前发现代码中存在的已知弱点并进行修复。

开发者应尽可能使代码安全。与其仅瞄准特定安全等级的符合性要求，不如确保代码尽可能多地实现本规范的要求（根据[GP]尽可能满足更多要求），这有助于确保开发者已考虑本规范解决的所有漏洞。

除了明显的声誉收益外，开发者还将从这一过程中学习，提高对潜在弱点的理解，从而完全避免这些弱点。

对开发和部署智能合约的组织而言，这一流程减少了安全审查所需的工作量，并降低了对其信誉、资产和其他资本的风险。

### 1.4 漏洞反馈与新漏洞
工作组欢迎对本规范的反馈：实施经验、改进清晰度的建议，或对特定章节或要求难以理解的疑问。

我们特别希望获得关于使用标准机器可读格式进行有效符合性声明的反馈，包括这种格式是否适合存储在区块链上，以及其他用例。

EEA成员可通过加入工作组提供反馈。任何人都可通过Ethtrust-public Github仓库或发送邮件至EEA Editor提供反馈，邮件将被转发给工作组。

我们预计本规范发布后将发现新的安全漏洞。为确保将它们纳入修订版本，我们欢迎相关通知。EEA已创建特定电子邮件地址接收新安全漏洞通知：security-notices@entethalliance.org。

发送至该地址的信息应足以识别和纠正描述的问题，并应包括对该问题的其他讨论的引用。这些信息将由EEA工作人员评估，然后转发给工作组解决问题。

当这些漏洞影响Solidity编译器，或建议修改编译器以帮助缓解问题时，还应按照[solidity-reports]中的描述通知Solidity开发社区。

## 2. 符合性
### 2.1 符合性声明
本规范中的关键词"可以(MAY)"、"必须(MUST)"、"不得(MUST NOT)"、"建议(RECOMMENDED)"和"应当(SHOULD)"应按照BCP 14 [RFC2119][RFC8174]中的说明进行解释，且仅当这些词汇以全大写形式出现时才具有此特定含义。

本规范定义了若干要求。如§1.1.3所述，每个要求都有安全等级([S]、[M]或[Q])和被测代码必须满足的声明。为获得特定安全等级的EEA EthTrust认证，被测代码必须满足该安全等级的所有要求，包括更低安全等级的所有要求。某些要求可以直接满足，也可以通过满足一个或多个覆盖要求来视为满足。

本文档不产生任何方的主动合规义务，但潜在客户或投资者通过合同谈判或其他流程可能会产生合规要求。

§5.4推荐良好实践章节包含更多建议。虽然它们格式与要求类似，但以"[GP]"标记开头。不要求测试这些内容；但建议谨慎实施和测试。

请注意，良好实施§5.4推荐良好实践可以增强安全性，但在某些情况下，不完整或低质量的实施可能会降低安全性。

### 2.2 谁可以提供EEA EthTrust认证？
本版本规范未对谁能执行审计和提供EEA EthTrust认证做出任何限制。没有为出具认证的审计师或工具定义认证流程。这意味着审查员关于执行准确测试的声明是由他们自己做出的。对于提供EEA EthTrust认证第2版认证的任何人，始终存在欺诈、虚假陈述或无能的可能。

注意：
原则上任何人都可以提交智能合约进行验证。但提交者需要注意使用限制，如版权条件等。此外，在智能合约开发控制有限的情况下，证明满足某些要求可能更加困难。工作组期望其成员（他们编写了本规范）保持高标准的诚信，并熟悉本规范，同时注意到还有许多其他人也这样做。工作组或EEA可能会为EEA EthTrust安全等级规范后续版本开发审计师认证计划。

### 2.3 识别认证内容
EEA EthTrust评估针对被测代码执行，被测代码是指智能合约或几个相关智能合约的Solidity源代码，以及使用指定参数编译代码生成的字节码。如果被测代码被划分为可部署在不同地址的多个智能合约，则称为合约集合。

## 3. 安全考虑
### 3.1 智能合约的上下文 - 更广泛的考虑
信息系统安全是一个主要的工作领域。任何中等复杂度的系统都存在固有风险。本规范描述了以太坊智能合约中安全问题的测试。然而，不存在完美的安全性。EEA EthTrust认证意味着至少已对智能合约执行了定义的最小检查集。这并不意味着被测代码绝对没有安全漏洞。新的安全漏洞会不时被发现。手动审计程序需要技能和判断力。这意味着始终存在审查中未注意到漏洞的可能性。

### 3.2 可升级合约
以太坊中的智能合约默认是不可变的。然而，在某些场景下需要修改它们，例如添加新功能或修复错误。可升级合约是通过启用对固定地址执行的代码的更改来满足这些需求的任何类型的合约。可升级合约的一些常见模式使用代理合约：用户直接与之交互的简单包装器，负责将交易转发到另一个合约（本文档中称为执行合约，也称为逻辑合约），该合约包含实际实现智能合约行为的代码。执行合约可以被替换，而作为访问点的代理合约永远不会更改。这两个合约在代码无法更改的意义上仍然不可变，但一个执行合约可以与另一个交换。因此，代理合约可以指向不同的实现，从而"升级"软件。这意味着遵循此模式使合约集合可升级的合约通常不能被视为不可变的，因为代理合约本身可以将调用重定向到新的执行合约，这些执行合约可能不安全或恶意。通过满足本规范中关于访问控制的要求以限制部署新执行合约的升级能力，并按照[Q]按文档实现记录升级模式并遵循该文档，被测代码的部署者可以证明可靠性。

通常，代理合约的EEA EthTrust认证不适用于可升级合约的内部逻辑，因此在通过代理合约升级到新执行合约之前需要对新执行合约进行认证。这种核心结构有多种可能的变体，例如包含多个执行合约的合约集合。在称为变形升级的攻击中，一系列智能合约用于说服人们（例如DAO中的投票者）批准部署某段代码，但链中的一个代理合约被更新为部署不同的恶意代码。其他模式依赖于使用`CREATE2`指令在已知地址部署智能合约。目前可以使用`selfdestruct()`方法删除该地址的代码，然后向该地址部署新代码。这种可能性有时用于节省Gas费用，但也用于变形升级攻击中。

### 3.3 预言机
以太坊网络的常见功能是使用预言机：可以提供来自链上或链下数据的信息的功能。预言机解决了一系列问题，从提供随机数生成到资产数据，管理流动性池的操作，以及实现对天气、体育或其他特殊兴趣信息的访问。预言机在DeFi和游戏中被大量使用，其中资产数据和随机化是协议设计的核心。

本规范包含检查智能合约是否足够健壮以正确处理返回的任何信息的要求，包括可能被故意制作用于预言机特定攻击的畸形数据的可能性。虽然预言机的某些方面在本规范范围内，但预言机仍可能提供错误信息，甚至主动产生有害的虚假信息。两个关键的考虑因素是数据损坏或被操纵的风险，以及预言机故障的风险。与这些考虑因素相关的漏洞 - 过度依赖`[TWAP](https://entethalliance.org/specs/ethtrust-sl/v3/#dfn-twap)`，以及对预言机故障的不安全管理 - 已经反复发生，导致各种DeFi协议损失数百万美元的价值。虽然有许多高质量和可信的预言机可用，但即使使用合法数据也可能遭受攻击。当调用预言机时，需要检查接收到的数据是否过时，以避免抢先交易攻击。即使在非DeFi场景中，例如随机性来源，通常也需要为每笔交易重置数据源，以避免下一笔交易的套利。

定价预言机的常见策略是提供时间加权平均价格（称为TWAP）。这在一定程度上防止了闪电贷攻击等突然飙升，但代价是提供过时信息。仔细选择时间窗口很重要：当时间窗口太宽时，它不会反映波动的资产价格，给套利者留下机会。然而，资产的"瞬时"价格通常不是一个好的数据点：它是预言机数据中最容易被操纵的部分，而且几乎总是在交易执行时就已经过时。使用整理各种来源数据、从数据中清除异常值并受到社区好评的预言机更有可能可靠。如果预言机是链下的，它反映的是链上数据的过时还是真正链下数据的可靠和准确是一个重要的考虑因素。即使使用选择良好的TWAP的预言机也可以操纵流动性池或其他DeFi结构，特别是通过利用闪电贷和闪电互换廉价筹集资金。如果目标操纵的资产流动性不足，则可能使其容易受到攻击者仅持有相对少量流动性的影响而导致大幅价格波动。

使用预言机时的第二个重要考虑因素是优雅的故障场景。如果预言机不再返回数据，或者突然返回一个不太可能的值，会发生什么？至少有一个协议因"挂起"在价格暴跌时很少发生的最低值而不是真正降至零而遭受损失，积累了大量接近零价格资产的交易者能够将其卖回协议。硬编码最小值或最大值可能导致反映现实的问题。

### 3.4 外部交互与重入攻击
依赖外部代码的代码可能引入多个攻击向量。这包括外部依赖包含恶意代码或通过安全漏洞受到恶意操纵的情况。然而，未能充分管理外部调用的可能结果也会引入安全漏洞。

以太坊智能合约中最常被引用的漏洞之一是重入攻击。这些攻击允许恶意合约在原始合约的函数调用完成之前回调到调用它的合约中。这种效果导致调用合约以意外的方式完成其处理，例如，对状态变量进行意外更改。

虽然[Check-Effect-Interactions](https://docs.soliditylang.org/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern)实现模式提供了关键保护，但新兴的跨合约交互模式可能需要额外的保障措施。定期审查交互模式有助于识别新的重入向量。

只读重入攻击发生在视图函数读取随后将被更改的状态时。这些攻击特别危险，因为此类函数通常缺乏保障措施，因为它们不修改合约的状态。然而，如果状态不一致，可能会报告不正确的值。这种欺骗可能导致其他协议读取不准确的状态值，从而可能导致意外操作或结果。这个问题可能影响依赖这些视图函数准确报告状态的其它合约，以及被重入的合约本身。因此，调用智能合约的第三方以及由合约集合组成的协议可能容易受到只读重入的影响。
```
示例7：Rari协议只读重入攻击​​
在Rari协议攻击中，攻击者通过大额闪电贷存入资金，在借款调用期间触发Comptroller合约的exitMarket()函数。该函数读取cETH合约状态时发生只读重入。由于cETH合约尚未记录借款状态，攻击者得以赎回初始存款并保留借款资金。详见[certik-rari]分析报告。
```
### 3.5 签名机制
本规范中的一些要求涉及可延展签名。这些是根据方案创建的签名，给定消息和签名，可以高效计算不同消息的签名 - 通常是以特定方式转换的消息。虽然这种签名方案允许有价值的用例，但如果不谨慎使用可能导致漏洞，这就是为什么本规范试图适当限制其使用。同样，对于使用可延展输入创建的可延展签名消息，哈希冲突可能发生。

本规范中的其他要求与利用用于创建签名消息的输入中的模糊性进行攻击有关。当签名消息不包括关于其预期使用位置、时间、次数等的足够识别信息时，消息签名可能被用于（或重复用于）非预期功能、合约、链或时间。

有关此主题的更多信息以及潜在利用，请参见[chase](https://smeiklej.com/files/csf14.pdf)。

### 3.6 Gas与Gas价格
Gas攻击是故意滥用以太坊用于调节计算能力消耗的Gas机制，以防范意外或不利结果（如拒绝服务攻击）。由于以太坊设计将Gas机制作为调节功能，仅检查交易是否有足够的Gas是不够的；检查Gas攻击需要考虑被测代码实现的目标和业务逻辑。

Gas虹吸是另一种滥用以太坊用于调节计算能力消耗的Gas机制的行为，攻击者从易受攻击的合约中窃取Gas，要么拒绝服务，要么为自己谋利（例如铸造Gas代币）。与Gas攻击类似，检查Gas虹吸需要仔细考虑被测代码实现的目标和业务逻辑。

Gas代币在铸造时使用Gas，在销毁时释放略少的Gas，前提是EVM退还足够数量的Gas以清除状态。当Gas价格低时铸造的Gas代币可以在Gas价格高时燃烧以补贴以太坊交易。在以太坊主链上，随着2021年8月部署[EIP-3529]的伦敦硬分叉，Gas退款被移除，实际上禁用了Gas代币。此外，以太坊网络升级的常见功能是更改特定操作的Gas价格。EEA EthTrust认证仅对指定的EVM版本有效；对其他EVM版本无效。因此，重新检查代码以确保其安全属性在网络升级中保持不变或采取补救措施非常重要。

### 3.7 MEV（恶意提取价值）
`MEV(Maliciously Extracted Value)`在本文档中表示"恶意提取价值"，指的是区块生产者或区块链的其他参与者通过恶意重新排序交易或抑制交易，或通过提出交易或采取其他行动获取非预期利益（即窃取）的可能性。描述为排序攻击的攻击也可用于利用MEV。
```
示例8：MEV攻击实例​​
当智能合约承诺奖励首个回答问题的交易时，区块生产者可以窃取其他交易中的答案，并丢弃包含该答案的所有其他交易。
```

一些MEV攻击可以通过仔细考虑交易中包含的信息（包括合约所需的参数）来防范。其他缓解策略包括针对排序攻击的保护措施。以太坊基金会维护有关MEV的信息资源集[EF-MEV]。

### 3.8 排序攻击
各种攻击与恶意重新排列区块中的交易有关，例如通过重新排序、审查或插入特定交易。虽然这类攻击的主要动机是促进MEV攻击，但它们也可用于为其他类型的攻击创造条件。
```
**警告**
示例9：排序攻击
投票合约的设置阶段有时可能被恶意抑制或抢跑投票选项提案所利用，以限制投票阶段符合条件的候选人数量。区块提议者可以在知道他们将产生一系列区块时恶意安排此类投票初始化期。
```
排序攻击有多种类型：
- 审查攻击
区块处理器主动抑制提议的交易，为自己谋利。
- 抢跑
基于在添加到区块之前可见的交易，允许恶意参与者提交替代交易，挫败原始交易的目的。
```
示例10：抢跑攻击策略
在一个旨在认证原创著作权的系统中，恶意参与者利用著作权声明中的信息伪造竞争性声明，并率先将伪造声明加入区块，从而为其虚假主张作者身份提供依据。
若重复实施此类攻击，将成为针对该服务本身的有效拒绝服务(DoS)攻击手段。
```
- 尾随
类似于抢跑，但攻击者将他们的交易放在被攻击的交易之后。
- 三明治攻击
攻击者将受害者的交易不理想地放在另外两个交易之间。
```
示例11：三明治攻击策略​​
攻击者构造代币买入交易插入受害者买单之前推高价格，再在抬高的价位插入对应卖单，通过这种"夹心"操作实现无风险套利。
```

注意
与利用MEV一样，区块生产者处于利用任何排序漏洞的最佳位置。如果他们提前知道他们将在未来产生特定区块，这一点尤其成立。例如参见[futureblock]或[postmerge-mev]。

实现等级[Q]要求[Q]对敏感操作使用时间锁延迟可以防止排序攻击影响敏感操作的执行。其他缓解策略包括使用哈希承诺方案[hash-commit]、批量执行或使用第2层[EEA-L2]链进行处理。

3.9 源代码、编译指示和编译器
本规范版本要求编译的字节码以及构成被测代码的Solidity源代码。Solidity在很大程度上是以太坊智能合约最常用的编程语言，要求Solidity源代码的好处包括简化许多测试，并且有大量针对Solidity源代码的安全研究。

Solidity允许源代码使用编译指示语句指定使用的Solidity编译器版本。本规范不要求任何特定的Solidity编译器版本，只要其不低于0.3.0，但在安全等级[Q]下，仅允许EEA EthTrust认证用于一组有限的Solidity编译器版本，已知这些版本的Solidity编译器在相同选项下从给定源代码生成相同的字节码。

要求合约只是Solidity源代码有一些缺点。最明显的是某些代码不是用Solidity编写的。不同的语言有不同的特性，通常支持不同的编码风格。也许更重要的是，这意味着用Solidity编写的已部署合约不能直接测试，除非有人提供源代码。引入源代码读取的另一个重要限制是它容易受到同形文字攻击（[Homoglyph Attacks](https://entethalliance.org/specs/ethtrust-sl/v3/#dfn-homoglyph-attacks)），其中看起来相同但不同的字符（如拉丁字母"p"和西里尔字母"р"）可以欺骗人工阅读源代码的人，掩盖恶意行为。还有相关的攻击使用诸如Unicode方向控制字符之类的功能，或利用组合字符的不一致规范化来实现相同类型的欺骗。

### 3.10 合约部署
本规范主要解决智能合约代码中出现的漏洞。然而，需要注意的是，智能合约的部署通常是协议操作的关键要素。智能合约安全的某些方面主要取决于被测代码的部署方式。即使经过审计的协议如果部署不当也可能容易被利用。

为特定区块链编写的代码可能依赖于该区块链可用的功能。当代码部署到兼容但不同的链时，功能差异可能暴露漏洞。对于部署到使用EVM补丁分叉的区块链或平行链的任何合约，在虚拟机级别可能不再适用常见的安全假设。首先将EEA EthTrust认证的合约部署到每个链的测试网，并进行彻底的渗透测试是有价值的。

特别令人担忧的是可升级合约的问题，以及部署中具有初始化函数的任何合约。许多协议因意外保留其初始化函数不受保护，或在部署中未在同一交易中调用初始化函数的非原子部署而被黑客攻击。这种情况容易受到抢跑攻击，并可能导致协议被恶意方接管，以及资金被盗或丢失。在与合约部署相同的交易中初始化合约可降低恶意行为者控制合约的风险。

此外，在构造函数和初始化函数中为`msg.sender`或其他变量分配访问角色对部署的影响需要仔细考虑。这在§5.3.2访问控制要求中进一步讨论。存在专门用于安全代理使用和安全合约部署的多个库和工具。从命令行工具到库再到复杂的基于UI的部署工具，存在许多解决方案来防止不安全的代理部署和升级。对给定合约的初始化函数使用访问控制，并限制在部署时或部署后可以调用初始化函数的次数，可以增强协议本身及其用户的安全性和透明度。此外，禁用重新初始化执行合约能力的函数可以防止以后的攻击或事故。

虽然本规范不要求被测代码已部署，但某些要求在代码部署到区块链时更容易测试，或者在某些情况下可能只能"在现场"彻底测试。

### 3.11 部署后监控
虽然智能合约部署后的监控超出了本规范的正式范围，但它是智能合约安全的重要考虑因素。新的攻击技术会不时出现，某些攻击只能通过实时实施的主动措施来防范。对链上活动的监控可以帮助在攻击造成不可挽回的损失之前检测到它们。监控（基于自动化数据集）可以识别已在其他地方发生的攻击，甚至是在其他区块链上。自动化监控可以促进快速响应，生成警报或自动启动操作，提高合约的安全性，否则当安全响应延迟甚至几个区块时，合约可能会受到损害。然而，区分攻击和个人异常行为可能很困难。纯粹依赖自动化监控会使区块链面临恶意行为者故意触发自动安全响应以破坏区块链或项目的风险，类似于拒绝服务攻击。

### 3.12 网络升级
EVM或以太坊虚拟机作为以太坊网络的分布式状态机，计算由交易引起的状态变化。EVM维护简单以太转账以及更复杂的智能合约交互的网络状态。换句话说，它是运行智能合约代码的"计算机"（尽管实际上是软件）。以太坊社区不时实施网络升级，有时也称为硬分叉。这是对以太坊的向后不兼容更改。因为它们通常会更改EVM，所以以太坊主网网络升级通常对应于EVM版本。

网络升级可能影响以太坊的更多或更少任何方面，包括更改EVM操作码或其Gas价格、更改添加块的方式或支付奖励的方式等许多可能性。由于不保证网络升级向后兼容，较新的EVM版本可能以意外的方式处理字节码。如果网络升级更改EVM以修复安全问题，考虑该更改很重要，遵循该升级是一个好习惯。因为对本规范的符合性声明仅对特定的EVM版本有效，所以网络升级可能意味着需要更新的审计以维护对当前以太坊网络有效的EEA EthTrust认证。网络升级通常只影响少数功能。这有助于限制升级后审计代码所需的努力：通常不会有影响被测代码的更改，或者审查受网络升级影响的唯一部分的一小部分就足以更新EEA EthTrust认证。

### 3.13 组织与链下安全态势
智能合约安全不仅限于代码，还涵盖组织流程和链下基础设施。全面的安全策略需要解决协议管理的技术和运营两个方面。

**运营安全措施包括：**
- 关键密钥存储的硬件安全模块(HSM)
- 分布式密钥持有者的多重签名方案
- 所有团队成员的定期安全培训
- 安全开发环境协议

**基础设施安全包括：**
- 受保护的部署基础设施
- 安全通信渠道
- 访问控制系统
- 网络安全监控

**监控和响应包括：**
- 实时交易监控
- 自动警报系统
- 事件响应程序
- 紧急关闭能力

**旨在遵循最佳实践的组织将实施：**
- 定期对链上和链下系统进行安全评估
- 记录明确角色和职责的事件响应计划
- 基础设施的定期渗透测试
- 安全意识培训计划
- 访问控制审查和更新
```
示例12：安全运营中心监控项​​
健全的安全运营中心(SOC)应监控：非常规交易模式、可疑管理操作、基础设施安全警报、智能合约异常行为。
```
3.14 预防链上对抗条件
智能合约在高度对抗的环境中运行，其中网络条件、外部数据源和经济激励可能被恶意行为者操纵。在部署前模拟这些攻击场景对于识别在标准测试条件下可能不会显现的漏洞至关重要。
需要模拟的关键对抗场景包括：
**网络操纵：**
- 极端Gas价格波动
- 故意造成网络拥堵
- 矿工策略性交易排序
- 区块时间戳操纵

**预言机攻击：**
- 通过闪电贷操纵价格反馈
- 延迟或过时数据场景
- 多种预言机故障模式
- 跨链预言机不一致

**经济战：**
- 极端资产价格波动
- 流动性池操纵
- 代币经济攻击
- 套利利用

**治理利用：**
- 代币投票操纵
- 提案泛滥攻击
- 投票期的定时攻击
- 恶意参数更新

标准测试环境通常无法捕捉这些对抗条件之间的复杂交互。在受控测试下看起来安全的协议，当多个攻击向量组合或经济激励足够大时，可能隐藏关键漏洞。

注意：动态测试环境
测试这些场景需要能够模拟复杂市场条件和参与者行为的动态环境。简单的单元测试或静态分析工具无法充分建模这些对抗情况。

通过在部署前建模这些场景，开发者可以：
- 识别经济模型中的边缘情况
- 验证断路器机制
- 测试紧急关闭程序
- 检查治理保障措施
- 评估压力下的协议弹性

## 4. 测试方法
### 4.1 单元测试
单元测试实践基于多个独立测试用例，每个测试用例验证特定需求。这种方法可融入测试驱动开发（TDD）流程，即在编写代码时同步构建测试用例集，确保变更不会引入已解决问题或新问题。

测试覆盖率是评估单元测试价值的关键指标，意味着不仅需要覆盖每个需求，还需覆盖触发该需求的所有可能路径。例如，测试tx.origin指令时，需同时测试其在Solidity代码和assembly{}中的使用场景，否则无法满足特定需求的全覆盖测试。

典型的单元测试自动化方案包括构建测试工具链，确保无论智能合约代码或运行环境发生变更（如集成新服务或系统），测试用例都能自动执行。

### 4.2 静态分析
静态分析指直接检查被测代码以识别潜在问题。本规范中，安全等级[S]的所有问题均可通过自动化静态分析发现。企业以太坊联盟（EEA）的EthTrust安全等级工作组已开始收集相关工具信息，并构建测试用例库验证工具准确性。

人工静态分析同样重要，该方法依赖专家的经验和判断力识别代码编写方式可能导致的问题。工作组认为人工静态分析足以验证被测代码是否符合本规范安全等级[M]的要求。

### 4.3 模糊测试
模糊测试是通过向合约输入多样化数据来暴露缺陷的自动化测试方法。其有效性很大程度上取决于语料库质量——即测试输入数据集。维护语料库时需平衡代码覆盖率与效率，剔除冗余或重复输入。

模糊测试主要分为三类：

​​黑盒测试​​：将智能合约视为不透明目标，仅通过外部接口测试，适用于快速发现典型使用场景中的基础错误。
​​白盒测试​​：基于完整源代码和执行路径可见性，使用符号执行等技术指导输入生成，能更精准定位复杂逻辑缺陷。
​​灰盒测试​​：结合前两种方法要素，通过有限插装或启发式方法生成测试输入，在检测广度与深度间取得平衡。
### 4.4 变异测试
变异测试通过向源代码注入人工缺陷（变异）来评估测试用例的有效性。若测试用例能检测到变异（即"杀死"变异体），说明测试充分；否则表明存在覆盖缺口。

智能合约适用的变异操作包括：

​​状态变量变异​​：修改状态变量的声明和操作
​​算术运算变异​​：替换运算符（+,-,*,/）或引入溢出条件
​​控制流变异​​：反转条件语句或修改循环逻辑
​​访问控制变异​​：移除权限检查或修改认证逻辑
关键指标是变异分数（被杀死的变异数/非等价变异总数）。虽然100%的分数难以实现，但对核心合约组件应保持高分。该技术通过识别等价变异（不影响行为的变异）来优化测试效率，可作为模糊测试的补充。

### 4.5 符号执行
符号执行通过追踪符号值（类似代数中的未知变量）而非具体数值来分析程序。该方法能推导出可能输出结果的约束条件，用于检测潜在漏洞，同时可识别死代码、未使用变量等问题。详见符号执行权威指南[WSE]。

### 4.6 形式化验证
形式化验证是用数学方法证明代码特性的技术族，在嵌入式系统等领域有成熟应用。在智能合约中，可用于验证协议不变量的安全性，或证明特定程序执行特性。

典型流程包括：

将智能合约预期行为转化为形式化规范（数学描述）
通常需要将合约代码转换为专用验证语言
使用证明工具（如Coq、Isabelle）进行数学验证
虽然能提供其他方法无法实现的保证，但其正确性依赖于模型与原始代码的准确对应，通常需要专业知识和大量人工工作。智能合约的不可篡改性使得该技术更具吸引力。以太坊基金会文档[EF-SL]列举了多种适用工具。

### 4.7 属性与不变量
基于属性的测试通过定义系统应满足的特性或不变量（在任何情况下都应保持的条件），自动生成测试场景。不变量测试是其子集，专门验证这些不变条件的保持性。

### 4.8 测试网部署
除静态分析外，多数测试方法需要执行被测代码。为避免主网风险，通常将代码部署到专门测试网络。测试网具有以下特点：

使用无实际价值的测试代币
允许包含已知漏洞的合约存在
提供与主网相似的环境而不造成真实损失

## 5. EEA EthTrust安全等级
### 5.1 安全等级[S]
EEA EthTrust认证在安全等级[S]下，旨在允许未经引导的自动化工具分析大多数合约的字节码和源代码，并确定它们是否符合要求。安全等级[S]的要求设计为可使用自动化静态分析进行测试。截至本规范版本，工作组已开始维护（工具注册表），其中列出了声称覆盖特定要求的工具，以及测试用例和在这些工具中运行它们的结果。更多信息请参见[ET-tools](https://github.com/EntEthAlliance/ethtrust-tool-registry/)。

对于某些难以自动验证的情况，存在更高级别的覆盖要求，可以通过满足这些要求来实现合规性。为了获得EEA EthTrust认证的安全等级[S]，被测代码必须满足所有安全等级[S]的要求，除非它满足适用的覆盖要求中的每一项要求。
```
编码哈希时包含chainid
[S] 哈希编码需包含chainid
被测代码必须按照[EIP-155]的建议，在交易哈希中纳入chainid值。
```
[EIP-155]描述了一种增强的哈希规则，通过在哈希中纳入链标识符。虽然这仅在存在唯一链标识符时才能防止重放攻击，但使用该机制可以提供一定程度的鲁棒性，并大大增加执行重放攻击的难度。

```
[S] 禁用CREATE2
被测代码不得包含CREATE2指令，除非满足以下覆盖要求集：

[M] 保护CREATE2调用
[M] 记录特殊代码用途
```
CREATE2操作码提供了与尚未在链上存在但可能最终包含代码的地址进行交互的能力。虽然这对于部署和与合约的反事实交互很有用，但它允许调用尚未知或可能被修改的代码，这些代码可能由于错误或保护不足而变得恶意或不安全。
```
[S] 禁用tx.origin
被测代码不得包含tx.origin指令，除非满足覆盖要求[Q]验证tx.origin用法。
```
tx.origin是Solidity中的一个全局变量，返回发送交易的账户地址。使用tx.origin的合约可能允许授权账户调用恶意合约，使恶意合约能够在非预期情况下通过授权检查。更好的做法是使用msg.sender进行授权。

参见[swcregistry]中的SWC-115获取示例。
```
[S] 禁用精确余额检查
被测代码不得测试账户余额是否完全等于（即==）指定金额或变量值，除非满足覆盖要求[M]验证精确余额检查。
```
以账户余额作为某些操作的基础存在风险，包括意外接收以太币或其他代币，包括故意转移代币以使此类测试失败的MEV攻击。

参见相关要求：
[M] 随机性来源
[M] 不要滥用区块数据
[Q] 防范MEV攻击
以及本规范安全考虑中§3.7 MEV（恶意提取价值）小节，[swcregistry]中的SWC-132示例，以及[CWE-667]中描述的不当锁定问题。
```
[S] 禁止对连续可变长度参数进行哈希
被测代码不得对连续的可变长度参数使用abi.encodePacked()。
```
在哈希之前，abi.encodePacked()的每个可变长度参数的元素按顺序打包。通过在连续的可变长度参数之间重新排列元素，同时保持它们连接顺序不变，可能导致哈希冲突。
```
[S] 禁用selfdestruct()
被测代码不得包含selfdestruct()指令或其现已弃用的别名suicide()，除非满足以下覆盖要求集：
```
[M] 保护自毁操作
[M] 记录特殊代码用途
如果selfdestruct()指令（或其已弃用的替代项suicide()）未得到妥善保护，恶意代码可以调用它并销毁合约，发送合约持有的任何以太币，从而可能窃取资金。还可以与CREATE2结合使用来更改特定地址的代码。此功能可能破坏不变性和去信任保证，引入众多安全问题。此外，一旦合约被销毁，发送的任何以太币都将丢失，这与禁用合约不同，后者会导致发送以太币的交易回滚。

自Solidity编译器版本0.8.18[solidity-release-818]起，selfdestruct()已被正式弃用，不鼓励使用。

参见[swcregistry]中的SWC-106和[EIP-6049]。
```
[S] 禁用assembly{}
被测代码不得包含assembly{}指令，除非满足以下覆盖要求集：

[M] 避免常见的assembly{}攻击向量
[M] 记录特殊代码用途
[M] assembly{}中的编译器错误SOL-2022-5
[M] 编译器错误SOL-2022-7
[M] 编译器错误SOL-2022-4
[M] 编译器错误SOL-2021-3
以及如果使用Solidity编译器版本0.5.5或0.5.6，还需满足[EthTrust-sl-v1]中的[M] assembly{}中的编译器错误SOL-2019-2。
```
assembly{}指令允许包含更低级别的代码。这使作者能够更强烈地控制生成的字节码，例如可用于优化gas使用。然而，它也潜在地暴露了许多漏洞和错误，这些都是额外的攻击面，并且有多种方法可以使用assembly{}引入故意设计的难以检测的恶意代码。

#### 5.1.1 文本和同形字
```
[S] 无Unicode方向控制字符  
被测代码不得包含任何Unicode方向控制字符  
U+2066、U+2067、U+2068、U+2029、  
U+202A、U+202B、U+202C、U+202D或U+202E  
除非它满足覆盖要求[M]无不必要的Unicode控制。
```
使用不可见的Unicode方向控制字符改变字符的显示顺序，可以在查看源代码时掩盖恶意代码，欺骗人工审计员。关于Unicode方向控制字符的更多信息，请参见W3C注释《如何为双向文本使用Unicode控制》[unicode-bdo](https://entethalliance.org/specs/ethtrust-sl/v3/#bib-unicode-bdo)。

[S] 无同形字式攻击  
被测代码不得使用同形字、Unicode控制字符、组合字符或多个Unicode区块中的字符，如果其影响具有误导性。

替换来自不同字母表或难以区分的字符，或使用方向控制字符或组合字符，可用于掩盖恶意代码，例如通过设计变量或函数名称来误导审计员。这些攻击被称为同形字攻击。[Ivanov]中描述了成功利用此问题的几种方法。在极少数情况下，变量名或标签中有效使用来自多个Unicode区块的字符（最可能是混合两种语言的名称），只要它们不误导或混淆读者，本要求允许它们获得EEA EthTrust认证。此级别要求检查同形字攻击，包括在单一字符集中的攻击，例如用"í"代替"i"或"ì"，阿拉伯语中"ت"代替"ث"，或数字"1"代替字母"l"，以及跨字符集的攻击，例如拉丁字母"a"和西里尔字母"а"或数学字符"𝚒𝚒"和拉丁字母"i"。如果审查员认为结果不必要地误导或混淆，则被测代码不符合此要求。另请参见相关要求：  
[S] 无Unicode方向控制字符。

#### 5.1.2 外部调用
另请参见相关要求：  
[M] 保护外部调用，和  
[Q] 验证外部调用。
```
[S] 检查外部调用返回  
使用低级调用函数（即call()、delegatecall()、staticcall()和send()）进行外部调用的被测代码必须检查每次使用的返回值以确定调用是否失败，除非它满足覆盖要求  
[M] 处理外部调用返回。
```
通常，调用中的异常会导致回滚。这将"冒泡"传播，除非在try/catch中处理。然而，Solidity定义了一组低级调用函数：  
- `call()`  
- `delegatecall()`  
- `staticcall()`
- `send()`

使用这些函数进行的调用行为不同。它们在失败时不会回滚，而是返回一个布尔值，指示调用是否成功完成。不显式检查返回值可能导致调用者合约中出现意外行为。依赖这些调用在失败时回滚会导致它们在未成功时出现意外行为。另请参见SWC-104 [swcregistry]，[error-handling]中描述的错误处理，未检查的返回值如[CWE-252]所述，以及相关要求：  
[S] 使用检查-效果-交互，  
[M] 处理外部调用返回，和  
[Q] 验证外部调用。
```
[S] 使用检查-效果-交互(Check-Effects-Interaction)  
进行外部调用的被测代码必须使用  
检查-效果-交互  
模式来防止重入攻击  
除非它满足以下覆盖要求集
[M] 保护外部调用，和  
[M] 记录特殊代码使用，
或它满足以下覆盖要求集
[Q] 验证外部调用，  
[Q] 记录合约逻辑，  
[Q] 记录系统架构，和  
[Q] 按文档实现。
```
检查-效果-交互模式是  
在进行任何状态更改之前验证所有前置条件，然后才在外部交互之前完成所有状态更新，然后才执行外部调用

以这种方式设计合约可显著减少重入攻击的范围。作为此模式的一部分，除了检查特定合约效果外，还可以测试协议不变量，以进一步确保请求不会产生不安全的结果。另请参见§3.4 外部交互和重入攻击，[c-e-i]中"Solidity安全注意事项"[solidity-security](https://entethalliance.org/specs/ethtrust-sl/v3/#bib-solidity-security)对"检查-效果-交互"的解释，"Solidity模式"[solidity-patterns]中的"检查效果交互"，以及[freipi](https://entethalliance.org/specs/ethtrust-sl/v3/#bib-freipi)。
```
[S] 无delegatecall()  
被测代码不得包含delegatecall()指令  
除非它满足以下覆盖要求集：
[M] 保护外部调用，和  
[M] 记录特殊代码使用，
或它满足以下覆盖要求集
[Q] 验证外部调用，  
[Q] 记录合约逻辑，  
[Q] 记录系统架构，和  
[Q] 按文档实现。
```
delegatecall()指令使外部合约能够操纵调用它的合约的状态，因为代码以调用者的余额、存储和地址运行。

#### 5.1.3 编译器错误
Solidity编译器的不同版本中存在许多已知的安全错误。本小节中的要求确保被测代码不会触发这些错误。要求的名称包括[solidity-bugs-json]中首次记录的错误的uid，作为可用于查找有关该错误的更多信息的关键字。[solidity-bugs]描述了用于JSON格式错误列表的约定。本小节中的要求按照受影响的最新Solidity编译器版本排序。

**注意**  
实施推荐的良好实践  
[GP] 使用最新编译器意味着被测代码  
通过本小节中的所有要求。  
一些与编译器相关的错误在§5.2.5安全等级[M]编译器错误和覆盖要求中  
作为安全等级[M]要求，要么是因为它们是  
本小节中要求的覆盖要求，要么是因为它们是  
安全等级[S]要求的覆盖要求集的一部分，这些要求已经确保  
错误无法被触发。  
一些错误是在已知的Solidity编译器版本中引入的，  
而其他错误已知或假设存在于所有Solidity编译器版本中，直到被修复。
```
[S] 编译器错误SOL-2023-3  
包含Yul代码并使用verbatim指令两次的被测代码，每次周围都有相同的代码，  
在使用Solidity编译器版本0.8.5至0.8.22（含）时必须禁用块重复数据删除器。
```
从Solidity编译器版本0.8.5到修复的0.8.22，块重复数据删除器错误地处理了verbatim项，  
意味着有时它会根据周围的代码混淆两个项，而不是正确比较它们。  
另请参见2023年11月8日的安全警报。
```
[S] 编译器错误SOL-2022-6  
ABI编码包含动态组件的元组（包括结构体、返回值或参数列表）的被测代码，  
并且其最后一个元素是基本类型uint或bytes32的calldata静态数组，  
不得使用Solidity编译器版本0.5.8至0.8.15（含）。
```
从Solidity编译器版本0.5.8到修复的0.8.15，使用ABIEncoderV2对元组进行ABI编码，  
其最后一个组件是基本类型uint或bytes32的calldata静态数组，  
可能导致数据损坏。  
另请参见2022年8月8日的安全警报。
```
[S] 编译器错误SOL-2022-5与.push()  
被测代码  
- 从calldata或内存复制字节数组  
- 其大小不是32字节的倍数，且有一个空的.push()指令写入结果数组，  
不得使用早于0.8.15的Solidity编译器版本。
```
直到Solidity编译器版本0.8.15，复制长度不是32字节倍数的内存或calldata  
可能暴露超出复制的数据，这些数据可以通过  
assembly{}观察到。  
另请参见2022年6月15日的安全警报和相关要求  
[M] assembly{}中的编译器错误SOL-2022-5。
```
[S] 编译器错误SOL-2022-3  
- 对同一函数使用内存和calldata指针，且  
- 在继承期间更改函数的数据位置，且  
- 在仅知道基合约中原始函数签名的位置进行内部调用  

不得使用Solidity编译器版本0.6.9至0.8.12（含）。
```
Solidity编译器版本从0.6.9到修复的0.8.13有一个错误，错误地允许  
内部或公共调用使用仅对外部调用有效的简化，将  
内存和calldata视为等效指针。  
另请参见2022年5月17日的安全警报。
```
[S] 编译器错误SOL-2022-2  
具有嵌套数组的被测代码  
- 将其传递给外部函数，或  
- 将其作为输入传递给abi.encode()，或  
- 在事件中使用它  
不得使用Solidity编译器版本0.6.9至0.8.12（含）。
```
Solidity编译器版本从0.5.8到修复的0.8.13有一个错误，意味着嵌套数组的  
单次编码和解码可以读取超出calldatasize()的数据。  
另请参见2022年5月17日的安全警报。
```
[S] 编译器错误SOL-2022-1  
被测代码  

对短于32字节的bytesNN类型使用数字字面量，或  
对任何bytesNN类型使用字符串字面量，  

并将此类字面量作为第一个参数传递给abi.encodeCall()，  
不得使用Solidity编译器版本0.8.11或0.8.12。
```
Solidity定义了一组变量类型，统称为  
bytesNN或固定长度变量类型，  
指定变量的长度为固定的字节数，遵循模式  
bytes1  
bytes2  
...  
bytes32

Solidity编译器版本0.8.11和0.8.12有一个错误，意味着在某些情况下，  
abi.encodeCall()会错误编码字面量参数。  
另请参见2022年3月16日的安全警报。
```
[S] 编译器错误SOL-2021-4  
使用短于32字节的自定义值类型的被测代码不得使用Solidity编译器版本0.8.8。
```
Solidity编译器版本0.8.8有一个错误，为不需要的自定义类型分配了完整的32字节存储空间。  
这可能被滥用来读取任意存储，  
如果被测代码包含使用不同Solidity编译器版本编译的代码，也可能导致错误。  
另请参见2021年9月29日的安全警报。
```
[S] 编译器错误SOL-2021-2  
使用abi.decode()对内存字节数组进行解码的被测代码  
不得在Solidity编译器版本0.4.16至0.8.3（含）中使用ABIEncoderV2。
```
Solidity编译器版本0.4.16引入了一个错误，在0.8.4中修复，意味着ABIEncoderV2  
在读取内存字节数组时错误验证了指针，这可能由于指针计算中的溢出错误而导致  
读取超出数组区域的数据。  
另请参见2021年4月21日的安全警报。
```
[S] 编译器错误SOL-2021-1  
具有两个或多个指令  
keccak(mem,length)的被测代码，其中  

mem的值相等，且  
length的值不等，且  
length的值不是32的倍数，  

不得在早于0.8.3的Solidity编译器版本中使用优化器。
```
Solidity编译器版本在0.8.3之前有一个优化器错误，意味着keccak哈希，  
针对相同内容但不同长度（不是32字节的倍数）计算，  
错误地使用了缓存中的第一个值而不是重新计算。  
另请参见2021年3月23日的安全警报。
```
[S] 使用现代编译器  
被测代码不得使用早于0.8.0的Solidity编译器版本，  
除非它满足EEA EthTrust安全等级规范版本2中的所有以下要求，  
作为覆盖要求：

[S] 无溢出/下溢  
[S] 编译器错误SOL-2020-11-push  
[S] 编译器错误SOL-2020-10  
[S] 编译器错误SOL-2020-9  
[S] 编译器错误SOL-2020-8  
[S] 编译器错误SOL-2020-6  
[S] 编译器错误SOL-2020-7  
[S] 编译器错误SOL-2020-5  
[S] 编译器错误SOL-2020-4

并且  
被测代码不得使用早于0.6.0的Solidity编译器版本，  
除非它满足EEA EthTrust安全等级规范版本1中的所有以下要求，  
作为覆盖要求：

[S] 编译器错误SOL-2020-11-length  
[S] 编译器错误SOL-2019-10  
[S] 编译器错误SOL-2019-3,6,7,9  
[S] 编译器错误SOL-2019-8  
[S] 编译器错误SOL-2019-5
[S] 编译器错误SOL-2019-4
[S] 编译器错误SOL-2019-2
[S] 编译器错误SOL-2019-1
[S] 显式存储（包括通过其覆盖要求  
[M] 如果适用则显式声明存储）
[S] 编译器错误SOL-2018-4
[S] 编译器错误SOL-2018-3
[S] 编译器错误SOL-2018-2
[S] 编译器错误SOL-2018-1
[S] 编译器错误SOL-2017-5
[S] 编译器错误SOL-2017-4
[S] 编译器错误SOL-2017-3
[S] 编译器错误SOL-2017-2
[S] 编译器错误SOL-2017-1
[S] 编译器错误SOL-2016-11
[S] 编译器错误SOL-2016-10
[S] 编译器错误SOL-2016-9
[S] 编译器错误SOL-2016-8
[S] 编译器错误SOL-2016-7
[S] 编译器错误SOL-2016-6
[S] 编译器错误SOL-2016-5
[S] 编译器错误SOL-2016-4
[S] 编译器错误SOL-2016-3
```
有许多已知的编译器错误影响早于0.6.0的Solidity编译器版本，  
但对编译器错误的研究往往集中在影响相对现代Solidity编译器版本的错误上，  
因此旧Solidity编译器版本中的任何进一步错误很可能只有在被利用后才会被发现并广为人知。  
使用现代Solidity编译器版本是一个良好的实践。  
在极少数情况下无法使用晚于0.6.0的Solidity编译器版本时，  
可以通过符合本规范版本1中定义的相关覆盖要求来实现EEA EthTrust认证。  
另请参见相关要求  
[M] 使用现代编译器，  
涵盖需要安全等级[M]审查的Solidity编译器错误。
```
[S] 无古老编译器  
被测代码不得使用早于0.3的Solidity编译器版本。
``
未跟踪早于0.3的Solidity编译器版本的编译器错误。  
因此存在未知错误可能导致意外问题的风险。  
另请参见[solidity-bugs-json]中的"SOL-2016-1"。

### 5.2 安全等级[M]
获得安全等级[M]的EEA EthTrust认证意味着合约经过人类审计或团队的手动分析，并且重要的安全问题均已解决至审计者满意为止。这一级安全要求是对等级[S]的补充，通常用于：
- 合约使用了不常见或高风险特性；
- 出现静态分析难以确认的安全性；
- 审计者需通过逻辑判断确定安全性。
```
为满足安全等级[M]，测试代码必须首先满足 § 5.1 的所有等级[S]要求，除非补充满足相应的“Overriding Requirement”来替代部分等级[S]要求
```
```
[M]显式消除求值顺序歧义
被测代码​​不得​​包含因变量求值顺序不同而导致结果差异的语句。
```
Solidity 中函数的求值顺序并非完全确定，且不同编译器版本间无法保证一致性。若语句调用的多个函数对共享状态对象产生副作用，求值顺序的差异可能导致不同结果。
此外，事件日志及`addmod/modmul`指令的求值顺序通常不符合常规模式，使用这些功能的被测代码可能产生预期外的结果。

⚠️ 风险示例
```
​​示例13：不确定的求值顺序​​
// 若函数 g() 和 h() 修改了函数 f() 所依赖的状态变量
f(g(x), h(y));  // 无法保证结果一致性
当 g() 和 h() 修改了 f() 依赖的状态变量时，该调用无法保证可复现的结果。
```
✅ 解决方案
通过临时变量显式控制执行顺序：
```​
​示例 14：使用临时变量强制求值顺序​​
// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

uint256 public myNumber;
uint256 public yourNumber;

function firstTransform(uint256 someNumber) public returns (uint256) {
    myNumber += 1;                // 副作用：修改状态
    return someNumber * myNumber; // 依赖更新后的 myNumber
}

function secondTransform(uint256 someNumber) public returns (uint256) {
    yourNumber += 3;              // 副作用：修改状态
    return someNumber / yourNumber; 
}

function deterministicResult(uint256 someNumber) public returns (uint256) {
    uint256 firstResult = firstTransform(someNumber); // 显式优先执行
    return secondTransform(firstResult);              // 显式后续执行
}
```
​​关键点​​：
使用 firstResult 临时变量分离执行步骤
确保 firstTransform 在 secondTransform 前完成
消除多函数调用的状态依赖歧义
关联参考
Solidity 隐蔽漏洞模式 [solidity-underhanded-richards2022](https://entethalliance.org/specs/ethtrust-sl/v3/#bib-solidity-underhanded-richards2022)
Solidity 速查指南 [solidity-cheatsheet](https://blog.soliditylang.org/2023/07/19/full-inliner-non-expression-split-argument-evaluation-order-bug/)
Solidity 编译器安全漏洞[SOL-2023-2](https://entethalliance.org/specs/ethtrust-sl/v3/#bib-solidity-bugs-json)
```
[M]验证精确余额检查
被测代码若检查账户余额​​严格等于​​（==）指定值或变量时，​​必须​​防范转账操作对余额检查的影响。
此为 [S] 级要求禁用精确余额检查的覆盖要求
```
若智能合约在执行过程中检查账户余额是否等于​​特定精确值​​，则存在潜在风险：攻击者可通过向该账户转账来改变其余额，导致交易意外回滚等非预期结果。若必须使用此类检查，​​必须​​实施防护措施以抵御此类攻击可能性。


#### 5.2.1 [M] 必须通过等级 [S]
[M] Pass Security Level [S]
若要获得等级 [M] 认证，测试代码（Tested Code）必须满足 § 5.1 安全等级 [S] 的所有要求，除非与每项对应的 “Overriding Requirement” 完全替代该要求
Enterprise Ethereum Alliance
。

5.2.2 [M] 显式消除变量评估顺序不确定性
[M] Explicitly Disambiguate Evaluation Order
测试代码中不得含有可能因表达式中函数调用顺序不同而产生不同结果的语句。Solidity 的函数评估顺序在多版本间可能不一致，尤其对 addmod, modmul 或事件参数等，可能影响逻辑执行结果
Enterprise Ethereum Alliance
。

示例（Example 13 与 Example 14）：

有如下代码可能导致顺序不确定：

java
Copy
Edit
// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

uint256 public myNumber;
uint256 public yourNumber;

function firstTransform(uint256 someNumber) public returns (uint256) {
  myNumber += 1; // 副作用
  return someNumber.mul(myNumber);
}

function secondTransform(uint256 someNumber) public returns (uint256) {
  yourNumber += 3; // 副作用
  return someNumber.div(yourNumber);
}

function deterministicResult(uint256 someNumber) public returns (uint256) {
  uint256 firstResult = firstTransform(someNumber);
  return secondTransform(firstResult);
}
以上写法中，若直接调用 f(g(x), h(y))，g 和 h 执行的顺序不确定，可能导致不同返回值。推荐将调用拆分为临时变量形式，如上所示的 deterministicResult，以明确顺序
Enterprise Ethereum Alliance
。

5.2.3 [M] 验证精确余额检查
[M] Verify Exact Balance Checks
如果合约中存在精确检查账户余额是否等于某个具体数值（即 == 操作），那么必须阻止该余额在检查前被他人转入，否则攻击者可能在检查执行时转账干扰，导致判断逻辑错误或交易回滚。这是对等级 [S] 中 “[S] No Exact Balance Check” 的 Overriding Requirement
Enterprise Ethereum Alliance
。

5.2.4 文本与同形字符攻击防护（5.2.1）
【M】禁止不必要的 Unicode 控制字符
[M] No Unnecessary Unicode Controls
除非确实用于正确显示文本，否则测试代码中不得包含 Unicode 方向控制字符，并且其使用不应误导源代码审计者。此项管理仅限于字符串文字，不适用于普通标识符；它是对等级 [S] 中 “[S] No Unicode Direction Control Characters” 的 Overriding Requirement
Enterprise Ethereum Alliance
。

【M】禁止同形字符攻击（同文字模拟欺骗）
[M] No Homoglyph‑style Attack
不得使用混用来自不同 Unicode 字符集、组合字符、或难以区分的同形字符（如：í 和 i／ì，阿拉伯文 ث 与 ت，Latin a 与 Cyrillic а 等）使阅读者误解变量名称、函数名称或合约逻辑。除非审计者认为这种使用合乎理由且不会误导，否则不允许；这也是对 “[S] No Unicode Direction Control Characters” 的 Overriding Requirement
Enterprise Ethereum Alliance
。

5.2.5 外部调用防护（5.2.2）
【M】必须保护所有外部调用
[M] Protect External Calls
如果测试代码中有外部调用（external call），则必须确保：

被调用地址对应的是同一 “Tested Code” 集合中的确切合约代码；

所有被调用合约都属于 Tested Code；

被调用合约由同一实体控制；

对于这些调用，必须提供与 Checks‑Effects‑Interactions 模式等效的重入攻击防御机制。

否则必须满足以下 等级 [Q] 级别的 Overriding 条件：

[Q] Verify External Calls

[Q] Document Contract Logic

[Q] Document System Architecture

[Q] Implement as Documented

这些额外条件允许部分外部调用通过场景理解和文档审计替代自动模式检测
Enterprise Ethereum Alliance
。

【M】防御只读函数的重入攻击
[M] Avoid Read‑only Re‑entrancy Attacks
测试代码如果调用其他合约的 view 函数，必须确保调用不会读取到中间不一致状态。这通常需要使用锁机制或状态检查 modifier，防止读取过程中被外部重入造成不一致。

示例（Example 15）：

solidity
Copy
Edit
// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

contract Reentered {
  function getPrice() public returns (uint256) {
    return totalSupply / numberOfEther; // 计算价格
  }
  function sellLPToken(uint256 amount) public nonReentrant {
    // ...
    numberOfEther -= amountToReceive;
    (bool success, ) = msg.sender.call{value: amountToReceive}("");
    require(success, "Transfer failed");
    LPToken.burnFrom(msg.sender, amount);
  }
}

contract Attacked {
  function buyToken(uint256 amount) public {
    uint256 tokenToReceive = Reentered.getPrice() * amount;
    // ...
  }
}

contract Attacker {
  function attack() public {
    Reentered.sellLPToken(LPToken.balanceOf(address(this)));
    // 触发 ETH 转账，从而触发 receive()
  }
  receive() external payable {
    Attacked.buyToken(1000);
  }
}
在上述场景中，receive() 中的 getPrice() 调用读取了还未更新的状态，导致计算错误，是典型的 view 函数重入攻击示例。

【M】合理处理外部调用返回值
[M] Handle External Call Returns
对于非默认 revert 的 low‑level 调用（例如使用 call、staticcall、delegatecall 或 send），必须合理地处理返回值（即判断 bool success），而不能假设未失败即表示成功。否则外部调用失败但不 revert 也可能导致逻辑错误，这是对 “[S] Check External Calls Return” 的 Overriding Requirement
Enterprise Ethereum Alliance
。

5.2.6 有防御性的代码使用说明（5.2.3）
【M】记录特殊代码使用并说明防护措施
[M] Document Special Code Use
所有包含下面内容的实例都必须在合约文档中说明其使用理由，并阐明相应的安全防护或设计依据，且文档须对合约调用者可见：

CREATE2

assembly { … }

selfdestruct() 或 suicide()

外部调用

delegatecall()

有可能发生溢出/下溢的操作

block.number 或 block.timestamp

使用 oracles 或伪随机性

这是对以下多个 [S] 需求的 Overriding Requirement：

[S] No CREATE2

[S] No selfdestruct()

[S] No assembly {}

[S] Use Check-Effects-Interaction

[S] No delegatecall()
Enterprise Ethereum Alliance

【M】确保数值计算的舍入不会被滥用
[M] Ensure Proper Rounding of Computations Affecting Value
若合约存在依赖舍入操作的数学逻辑，比如四舍五入、整除等：

必须文档化可能产生的误差范围；

不可因舍入造成价值意外增加或丢失；

舍入逻辑设计应防止攻击者通过来回交换谓“round‑trip”不断获利（如累计额外份额）。

这类问题在 DeFi 协议中真实发生过，可能造成数额小幅误差却重复累积被滥用。

示例（Example 16 与 Example 17）：

不安全写法：

solidity
Copy
Edit
// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

function xChangeTo(uint256 numberOfEth) public returns (uint256) {
  return numberOfEth.mul(rateThatCausesRounding); // 四舍五入
}

function xChangeFrom(uint256 numberOfOtherToken) public returns (uint256) {
  return numberOfOtherToken.div(rateThatCausesRounding); // 四舍五入
}
安全对策：“Keep the Change” 方法（示例 17）：

solidity
Copy
Edit
// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

function xChangeTo(uint256 numberOfEth) public returns (uint256) {
  return numberOfEth.mulDown(rateThatCausesRounding); // 向下舍入
}

function xChangeFrom(uint256 numberOfOtherToken) public returns (uint256) {
  return numberOfOtherToken.divDown(rateThatCausesRounding); // 向下舍入
}
该方法确保每次交易不会给攻击者带来优势，尽管仍可能累积舍入损失
Enterprise Ethereum Alliance
。

【M】保护合约自毁操作
[M] Protect Self‑destruction
如合约中使用 selfdestruct() 或其旧别名 suicide()：

必须保证只有授权方才能调用；

必须采用与该操作与作者声明一致的保护逻辑。

除非补充具备 [Q] Enforce Least Privilege 合规文档说明，否则不允许直接使用该操作。该项是对 “[S] No selfdestruct()” 的 Overriding Requirement
Enterprise Ethereum Alliance
。

示例（Example 18）：
这是 Parity 钱包多重签失败导致以太资金被冻结的案例，因合约中 selfdestruct() 被错误保护触发所引致。

【M】禁止不安全的 inline assembly 使用
[M] Avoid Common assembly {} Attack Vectors
使用 assembly { … } 时必须确保：

不会产生存储指针冲突；

不可允许将任意值写入类型为 function 的变量。

在设计中存在难以追踪的攻击面，因此只有在无法避免时才使用，并且需在文档中说明。该是对 “[S] No assembly {}” 的 Overriding Requirement 子集
Enterprise Ethereum Alliance
。

【M】保护使用 CREATE2 的调用
[M] Protect CREATE2 Calls
任何使用 CREATE2 部署合约时，需满足：

被部署合约必须包含在 Tested Code 内；

不得使用 selfdestruct(), delegatecall() 或 callcode()；

必须与合约作者的声明逻辑一致。

否则必须满足 [Q] Verify External Calls, [Q] Document Contract Logic, [Q] Document System Architecture, [Q] Implement as Documented 这四项 Overriding Requirement
Enterprise Ethereum Alliance
。

【M】禁止不安全算术溢出/下溢
[M] Safe Overflow/Underflow
除非确有业务需求（例如模运算），且代码带有溢出/下溢的检查或保护，测试代码不得包括可能导致溢出或下溢的计算。Solidity 0.8.0 以上默认开启算术检查，如果确实关闭，需要由审计者确认依然安全
Enterprise Ethereum Alliance
。

【M】伪随机性来源要足够安全
[M] Sources of Randomness
合约中如果使用随机性来源，则必须保证所用随机数难以被预测或操纵（如不能使用 block.timestamp, block.number, block.difficulty）。推荐采用可信链下或链上 oracle 提供的随机性服务
Enterprise Ethereum Alliance
。

示例（Example 19 与 Example 20）：

不安全：允许玩家猜测未来区块号的抽奖；

安全：只有准确匹配外部 lottery 结果的号码才获奖，不可提前猜测。

【M】避免滥用区块数据
[M] Don’t Misuse Block Data
不得将 block.timestamp 或 block.number 用作精确计时或随机性来源，否则攻击者（尤其是区块提议者/矿工）可操纵这些字段导致攻击。可以粗略使用，如 (block.number / 14 > 1800) 表示 30 分钟，但不可用于严格判断秒级时间差
Enterprise Ethereum Alliance
。

5.2.7 签名管理（5.2.4）
【M】正确验证签名
[M] Proper Signature Verification
若合约处理链下签名（例如 EIP‑712）进行账户授权或转账，必须调用 ecrecover() 并验证返回地址是否与预期一致，特别要判断若返回 address(0) 表示签名无效，需要拒绝逻辑。Solidity 0.4.14 之前的版本签名验证有已知漏洞需额外注意
Enterprise Ethereum Alliance
。

【M】防止签名重放误用
[M] No Improper Usage of Signatures for Replay Attack Protection
若合约使用签名防止重放攻击（Replay Attack），必须确保：

同一函数、同一消息不能重复验证；

不同函数也不能重复使用同一签名；

不同合约地址、跨链或跨函数不能重用签名；

不能使用可变签名（Malleable Signature）条款出现；

除非明确采用 [Q] Intended Replay 规范说明允许重用签名并控制后果，否则视为不合规
Enterprise Ethereum Alliance
。

5.2.8 Solidity 编译器已知漏洞与 Overriding Requirement（5.2.5）
若项目使用的 Solidity 编译器版本存在以下已知的安全 bug，必须满足以下条件：

避免使用受影响的编译器版本；

或者满足相应的 Overriding Requirement 由审计者确认安全；

推荐总是使用推荐的 viaIR 选项；

避免使用 inline assembly 并保持其调用范围可控；

以下是该级别的主要需求：

[M] Solidity Compiler Bug 2023‑1
若存在 .selector 的有副作用的复合表达式，使用 Solidity 0.6.2 到 0.8.20 版本时必须启用 viaIR 编译器选项
Enterprise Ethereum Alliance
。

[M] Compiler Bug SOL‑2022‑7
使用 inline assembly 并在其中包含存储写操作后条件终止（如 return() 或 stop()），Solidity 0.8.13 到 0.8.16 版本不能使用
Enterprise Ethereum Alliance
。

[M] Compiler Bug SOL‑2022‑5 in assembly {}
当从 calldata 或 memory 中拷贝字节数据长度不是 32 字节倍数，并用 assembly {} 读取时，Solidity 0.8.14 及以下（不含 0.8.15）版本存在超界可见漏洞，必须避开
Enterprise Ethereum Alliance
。

[M] Compiler Bug SOL‑2022‑4
在不同的 assembly {} 片段中写入与读取时使用共享内存，但某个优化路径下丢失该内存，Solidity 0.8.13 或 0.8.14 不可使用带 yulOptimizer
Enterprise Ethereum Alliance
。

[M] Compiler Bug SOL‑2021‑3
在 assembly {} 中读取 immutable 但短于 256 位的带符号整数时，Solidity 0.6.5 到 0.8.8 存在错误，不可使用
Enterprise Ethereum Alliance
。

[M] Use a Modern Compiler
Solidity 编译器不应低于 0.8.0 版本，除非满足版本范围内旧 bug 的 Overriding Requirement（例如从 v2 规范遗留要求）；最低不能低于 0.6.0 除非进一步满足前期版本的多个自定义 Overriding Requirement
Enterprise Ethereum Alliance
。